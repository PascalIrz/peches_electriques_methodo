---
title: "Mesures pêches électriques"
author: "OFB - DR Bretagne"
date: "11/01/2021"
output: 
  rmdformats::readthedown:
    use_bookdown: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r packages}
library(tidyverse)
library(corrplot)
library(RColorBrewer)
library(pechelec)

couleurs <- brewer.pal(n = 8, name = "Dark2")
```

```{r}
load(file = "../processed_data/donnees.RData")
load(file = "../processed_data/graphiques.RData")
```

```{r}
# pb d'une valeur de température aberrante (220°C), inversée avec la conductivité + d'unité sur les profondeurs
data <- data %>%
  mutate(
    temperature = ifelse(station == "Loup a Plougonver" & annee == 2020,
                         14,
                         temperature),
    conductivite = ifelse(station == "Loup a Plougonver" & annee == 2020,
                         220,
                         conductivite),
    prof_moy = ifelse(prof_moy < 4,
                      prof_moy * 100,
                      prof_moy)
  )
```


# Contexte et données

Afin d'objectiver les conditions dans lesquelles se déroulent les opérations de terrain ainsi que les réglages des appareils, des mesures ont été réalisées à l'occasion de pêches à l'électricité sur les cours d'eau de Bretagne et des Pays-de-la-Loire au cours des années `r data %>% pull(annee) %>% min(na.rm = TRUE)` à `r data %>% pull(annee) %>% max(na.rm = TRUE)`. Ces opérations ont toutes été menées "en régie" par l'ex-AFB puis par l'OFB.

## Caractéristiques des stations pêchées

```{r}
stations %>%
  DT::datatable(
    colnames = c(
      "Station",
      "Dépt",
      "Type de pêche",
      "Anodes",
      "Distance anode cathode",
      "Largeur moyenne",
      "Largeur mesure",
      "Profondeur moyenne",
      "Profondeur mesure"
    ),
    rownames = FALSE
  )
```

## Les paramètres mesurés

Ces paramètres, mesurés pour chaque pêche, reflètent : 


* Des caractéristiques du milieu (conductivité de l'eau en $\mu S/cm$, température de l'eau en °C)  
* Le réglage de l'appareillage (Choix du cran sur le "Héron")   
* La résultante de l'interaction entre le milieu et l'appareil de pêche :  
    + Le champ créé par l'appareil sur le milieu, mesuré au moyen d'une sonde "Penny" placée à 1 ou 1,5m de la cathode et exprimé en V.m^-1^   
    + Les paramètres du courant électriques délivré (tension en V, intensité en A et puissance en kW)  
    
Tableau des données brutes :

```{r}
tableau_peches %>%
  DT::datatable(
    colnames = c(
      "Station",
      "Année",
      "Cran",
      "Conductivité",
      "Température",
      "Voltage",
      "Puissance",
      "Intensité",
      "Penny à 1m du centre",
      "Penny à 1,5m du centre",
      "Penny à 1,5m du bord"
    ),
    rownames = FALSE
  )
```

# Distribution des variables

On peut dans un premier temps examiner les valeurs prises par chacune des colonnes des tableaux.

>Nb : les valeurs moyennes sont indiquées en légende de l'axe horizontal et représentées par la ligne verticale en pointillés.

## Les stations


:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_histo(
  var = larg_moy,
  df = data,
  x_lab = "Largeur moyenne (m)"
)

gg_histo(
  var = prof_moy,
  df = data,
  x_lab = "Profondeur moyenne (m)"
)

gg_histo(
  var = dist_an_cat,
  df = data,
  x_lab = "Distance anode cathode"
)
```


:::

::: {}

```{r}
gg_histo(
  var = larg_mes,
  df = data,
  x_lab = "Largeur au pt de mesure (m)"
)

gg_histo(
  var = prof_mes,
  df = data,
  x_lab = "Profondeur au pt de mesure (m)"
)
```

:::

::::

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_barre(
  df = data,
  var = protocole,
  x_lab = "Type de pêche"
)
```


:::

::: {}

```{r}
gg_barre(
  df = data,
  var = anodes,
  x_lab = "Nombre d'anodes",
  type = "stations"
)
```

:::

::::


## Le milieu au moment des opérations

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_histo(
  var = conductivite,
  df = data,
  x_lab = "Conductivité (\U00B5S/cm)",
  type = "pêches"
)
```


:::

::: {}

```{r}
gg_histo(
  var = temperature,
  df = data,
  x_lab = "Température",
  type = "pêches"
)
```

:::

::::

## Les opérations

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_barre(
  df = data,
  var = protocole,
  x_lab = "Type de pêche",
  type = "pêches"
)
```


:::

::: {}

```{r}
gg_barre(
  df = data,
  var = cran,
  x_lab = "Cran de réglage du Héron",
  type = "pêches"
)
```

:::

::::

## Interaction opération x milieu

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_histo(
  var = intensite,
  df = data,
  x_lab = "Intensité",
  type = "pêches"
)

gg_histo(
  var = voltage,
  df = data,
  x_lab = "Voltage",
  type = "pêches"
)

gg_barre(
  df = data,
  var = cran,
  x_lab = "Cran de réglage du Héron",
  type = "pêches"
)
```


:::

::: {}

```{r}
gg_histo(
  var = puissance,
  df = data,
  x_lab = "Puissance",
  type = "pêches"
)

gg_histo(
  var = penny_15_centre,
  df = data,
  x_lab = "Mesure Penny à 1,5m du centre",
  type = "pêches"
)

gg_histo(
  var = dc,
  df = data,
  x_lab = "Densité de courant",
  type = "pêches"
)
```

:::

::::


# Lien entre les variables

## Corrélations

### Vue d'ensemble

On peut s'interroger sur les liens entre les variables. Certains sont évidents. Par exemple la puissance ($P$, exprimée en Watts)est le produit du voltage ($U$, en volts) et de l'intensité ($I$, en ampères) :

$P(W)=U(V)\cdot I(A)$

Il ne serait donc pas surprenant que la puissance ait tendance à augmenter quand le voltage et l'intensité augmentent.

On peut aussi penser qu'il y a un lien entre les propriétés électriques du milieu (sa conductivité) et les réglages du matériel pour obtenir l'effet souhaité sur les poissons.

Pour y voir plus clair, il est possible de visualiser les corrélations entre les couples de variables.

Les représentations graphiques ci-dessous indiquent :

* Sous la diagonale, les coefficients de corrélation
* Au-dessus de la diagonale, les nuages de points résumés par des ellipses.  

Pour l'interprétation :

* Plus l'ellipse est de forme allongée, plus le lien entre les deux variables est fort.
* Plus le coefficient de corrélation est proche de 1 (corrélation positive) ou de -1 (corrélation négative), plus le lien entre les deux variables est fort.
* La couleur bleue indique des corrélations positives (quand la première variable augmente, la seconde augmente également) et le rouge les corrélations négatives (relation inverse).
* Les croix indiquent les relations statistiquement non significatives au seuil de 5%.

>NB : Comme les distributions ne sont pas toutes "gaussiennes", on emploie ici la corrélation de Spearman.

Sur l'ensemble des données on obtient :

```{r}
# cormat <- cor(cor_tot %>% na.omit())
# 
#   M <- cormat %>%
#     as.matrix() %>%
#     Hmisc::rcorr(type = c("spearman"))
# 
# corrplot.mixed(
#     corr = M$r,
#     p.mat = M$P %>%
#     # replace_na(replace = 1),
#       misty::na.as(na = 1),
#     sig.level = .10,
#     upper = "ellipse",
#     tl.cex = 0.8#,
#   #  order = order
#   )

g_cor(cor_tot, order = "hclust")
```

Lecture : Quand la température de l'eau est élevée, les paramètres de conductivité, puissance et intensité tendent à être élevés (corrélations positives et significatives) tandis que le voltage est plutôt faible (corrélation négative). Le voltage et la mesure Penny tendent à varier dans le même sens (corrélation positive significative).

Pour évaluer la constance des relations, on peut les comparer en subdivisant le jeu de données.

#### Comparaison entre années

Les graphiques sont très semblables d'une année sur l'autre (non présenté ici).

#### Comparaison selon le nombre d'anodes

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1px; "}

::: {}
Une anode
```{r, fig.height = 8}
g_cor(cor_1a)
```
Le schéma pour une anode est pratiquement identique au schéma général.

:::

::: {}
Deux anodes
```{r, fig.height = 8}
g_cor(cor_2a)
```
Au sein des pêches à deux anodes, il est notable que la température n'est plus liée à aucun autre paramètre. On retrouve bien le groupe conductivité - intensité - puissance corrélées positivement et un autre groupe Penny - voltage. La mesure Penny à 1,5m est toujours corrélée positivement au voltage (cas génaral) mais négativement à la conductivité (interprétation ?).

:::

::::

#### Comparaison selon le cran

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1px; "}

::: {}
Cran 2
```{r, fig.height = 8}
g_cor(cor_cran2)
```
Au cran 2, les corrélations sont un peu différentes du schéma général, si ce n'est que la mesure Penny n'est plus corrélée à aucune variable.

Cran 4
```{r, fig.height = 8}
g_cor(cor_cran4)
```
Au cran 4, on observe n'observe plus que la très forte relation puissance - intensité. Il est possible que les données soient trop peu nombreuses.

:::

::: {}
Cran 3
```{r, fig.height = 8}
g_cor(cor_cran3)
```
Au cran 3, qui est le plus commun, les sens de corrélation (couleur des ellipses) sont cohérents avec le schéma général mais il avec moins de paires significatives.
:::

::::


#### Comparaison selon la méthode de pêche

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 1px; "}

::: {}

EPA à pieds
```{r, fig.height = 8}
g_cor(cor_epa_pied)
```
Pour les EPA à pieds, on retrouve le schéma général mais avec moins de relations significatives. Aucune corrélation avec la mesure Penny. On note que la relation température - conductivité est plus étroite qua dans le cas général.


:::

::: {}
Inventaire
```{r, fig.height = 8}
g_cor(cor_inv)
```
Pour les pêches d'inventaire, on retrouve à peu près le schéma général mais les corrélations sont plus faibles. La relation puissance - voltage, négative dans le cas général, est ici positive mais avec une faible corrélation.


:::

::::

### Relation Intensité - Conductivité


```{r}
graph_intens_cond
```

La relation intensité - conductivité est nette. Elle est très significative pour les crans 2 et 3, mais non significative pour le cran 4.

### Relation Penny - Conductivité

```{r}
graph_penny_cond
```

Rien de bien net ne se dégage ici (relations non significatives).

### Relation Densité de courant - Conductivité

```{r}
graph_dc_cond
```

La seule relation significative est sur le cran 3. Il y a un lien mais qui est faible.

## Lien entre variables qualitatives et quantitatives

:::: {style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-column-gap: 10px; "}

::: {}

**Cran de réglage du Héron**

```{r}
gg_boxplot(
  df = data,
  var_quant = voltage,
  var_quant_lab = "Voltage (V)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = puissance,
  var_quant_lab = "Puissance (kW)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = intensite,
  var_quant_lab = "Intensité (A)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = dc,
  var_quant_lab = "Densité de courant",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = penny_15_centre,
  var_quant_lab = "Mesure Penny à 1,5m",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = conductivite,
  var_quant_lab = "Conductivité (\U00B5S/cm)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = temperature,
  var_quant_lab = "Température (°C)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = dist_an_cat,
  var_quant_lab = "Distance anode-cathode",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = larg_moy,
  var_quant_lab = "Largeur moyenne (m)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
) +
  scale_y_continuous(limits = quantile(data$larg_moy,
                                       c(0.05, 0.95),
                                       na.rm = T))

gg_boxplot(
  df = data,
  var_quant = prof_moy,
  var_quant_lab = "Profondeur moyenne (cm)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
) +
  scale_y_continuous(limits = quantile(data$prof_moy, c(0.05, 0.95), na.rm = T))

gg_boxplot(
  df = data,
  var_quant = larg_mes,
  var_quant_lab = "Largeur à la mesure (m)",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)

gg_boxplot(
  df = data,
  var_quant = prof_mes,
  var_quant_lab = "Profondeur à la mesure",
  var_qual = cran,
  var_qual_lab = "Cran de réglage du Héron"
)
```


:::

::: {}

**Type de pêche**

```{r}
gg_boxplot(
  df = data,
  var_quant = voltage,
  var_quant_lab = "Voltage (V)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = puissance,
  var_quant_lab = "Puissance (kW)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = intensite,
  var_quant_lab = "Intensité (A)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = dc,
  var_quant_lab = "Densité de courant",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = penny_15_centre,
  var_quant_lab = "Mesure Penny à 1,5m",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = conductivite,
  var_quant_lab = "Conductivité (\U00B5S/cm)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = temperature,
  var_quant_lab = "Température (°C)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = dist_an_cat,
  var_quant_lab = "Distance anode-cathode",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = larg_moy,
  var_quant_lab = "Largeur moyenne (m)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
) +
  scale_y_continuous(limits = quantile(data$larg_moy, c(0.05, 0.95), na.rm = T))

gg_boxplot(
  df = data,
  var_quant = prof_moy,
  var_quant_lab = "Profondeur moyenne (cm)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
) +
  scale_y_continuous(limits = quantile(data$prof_moy, c(0.05, 0.95), na.rm = T))

gg_boxplot(
  df = data,
  var_quant = larg_mes,
  var_quant_lab = "Largeur à la mesure (m)",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)

gg_boxplot(
  df = data,
  var_quant = prof_mes,
  var_quant_lab = "Profondeur à la mesure",
  var_qual = protocole,
  var_qual_lab = "Type de pêche"
)
```

:::

::: {}

**Nombre d'anodes**

```{r}
gg_boxplot(
  df = data,
  var_quant = voltage,
  var_quant_lab = "Voltage (V)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = puissance,
  var_quant_lab = "Puissance (kW)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = intensite,
  var_quant_lab = "Intensité (A)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = dc,
  var_quant_lab = "Densité de courant",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = penny_15_centre,
  var_quant_lab = "Mesure Penny à 1,5m",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = conductivite,
  var_quant_lab = "Conductivité (\U00B5S/cm)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = temperature,
  var_quant_lab = "Température (°C)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = dist_an_cat,
  var_quant_lab = "Distance anode-cathode",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = larg_moy,
  var_quant_lab = "Largeur moyenne (m)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
) +
  scale_y_continuous(limits = quantile(data$larg_moy, c(0.05, 0.95), na.rm = T))

gg_boxplot(
  df = data,
  var_quant = prof_moy,
  var_quant_lab = "Profondeur moyenne (cm)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
) +
  scale_y_continuous(limits = quantile(data$prof_moy, c(0.05, 0.95), na.rm = T))

gg_boxplot(
  df = data,
  var_quant = larg_mes,
  var_quant_lab = "Largeur à la mesure (m)",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)

gg_boxplot(
  df = data,
  var_quant = prof_mes,
  var_quant_lab = "Profondeur à la mesure",
  var_qual = anodes,
  var_qual_lab = "Nombre d'anodes"
)
```

:::


::::


# Analyse des mesures Penny

## Relation entre mesure Penny et les autres variables

Pour estimer si la mesure Penny est liée à d'autres variables, il est possible de modéliser cette mesure en fonction d'autres variables quantitatives. Les matrices de corrélation on sait qu'en corrélation de Spearma, il existe un lien avec le voltage.


```{r}
DT::datatable(
  tab_bivar_penny,
  caption = "Le signe de la pente renseigne sur le sens de la relation.",
  rownames = FALSE,
  colnames = c(
    "Variable",
    "Pente",
    "Intercept",
    "p-value",
    "r\U00B2",
    "Significativité"
  )
)
```

On a donc la confirmation d'un lien statistique entre la mesure Penny et le voltage. La pente étant positive, la mesure Penny augmente quand le voltage augmente. Ce lien n'est toutefois pas très fort puisque le r² est de `r tab_bivar_penny %>% filter(variable == "voltage") %>% pull(rsq) %>% round(2) %>% "*"(100)`%, ce qui correspond à la part de la variabilité de la mesure Penny expliquée statistiquement par la variabilité du voltage. 

On observe également des liens, mais moins forts, avec les variables `r tab_bivar_penny %>% filter(pval <= 0.05 & variable != "voltage") %>% pull(variable) %>% paste(collapse = ", ")`.

# stabilité temporelle des valeurs ?

Sur les graphiques ci-dessous, la hauteur des barres indique la valeur moyenne du paramètre chaque année. La moyenne générale est représentée par la ligne pointillée horizontale. Si les intervalles de confiance au sommet des barres "chevauchent", il n'y a pas de différence entre les moyennes en 2018 et 2019. 

:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r}
gg_comp_moy(df = data, var = "voltage")
gg_comp_moy(df = data, var = "puissance")
gg_comp_moy(df = data, var = "intensite")
```


:::

::: {}

```{r}
gg_comp_moy(df = data, var = "conductivite")
gg_comp_moy(df = data, var = "penny_15_centre")
```

:::

::::

## Cran de réglage

Sur le graphique ci-dessous les stations sont ordonnées selon leur conductivité moyenne.

```{r, fig.height = 10}
gg_cran_annee(df = data,
              var_ordre = "conductivite")
```

# Le cran de réglage en fonction des autres variables

La question est de savoir s'il est possible de prédire le cran de réglage du Héron à partir des caractéristiques du site (les variables explicatives). On ne peut pas retenir comme variables explicatives celles qui sont elles-mêmes dépendantes du réglage du Héron (mesure Penny, intensité, etc.) sans quoi le raisonnement est circulaire.
.
Les variables explicatives "candidates" sont donc les caractéristiques générales du milieu (profondeur, largeur) et les mesures prises in situ en l'absence du courant électrique provoqué par l'appareil (conductivité, température).

## Sélection des variables potentielles d'après les graphiques

Il est peu probable qu'une variable qui ne montre graphiquement aucun lien avec le cran  de réglage ait un pouvoir explicatif. On commence donc par examiner les graphiques sur la colonne de gauche (cran) de la section \@ref(lien-entre-variables-qualitatives-et-quantitatives).

On relève que trois des variables semblent avoir des distributions différentes selon le cran de réglage : la température, la profondeur moyenne de la rivière et la conductivité (on retient ici le paramètre conductivité à 25°C qui est celui mesuré sur le terrain).

Pour la modélisation, il faut que le tableau de données ne comporte pas de données manquantes.

```{r, echo = TRUE}
data_sel <-
  data %>% select(cran,
                  prof_moy,
                  conductivite,
                  temperature) %>%
  drop_na()
```

## Colinéarite ?

```{r, echo = TRUE}
data_sel %>%
  mutate(cran = as.numeric(as.character(cran))) %>%
  round(2) %>%
  cor()
```

Ce n'est pas trop mal $\Rightarrow$ on peut passer à l'étape de modélisation

## Modélisation

La variable que l'on cherche à prédire est le cran de réglage, qui peut prendre trois modalités (2, 3 ou 4) qui sont ordonnées. C'est une variable "ordinale". On utilisera donc un modèle de type régression logistique ordonnée avec le package {MASS}.

La démarche comprend les étapes suivantes :

* Construction de modèles complets avec différents paramétrages
* Conservation du "meilleur"
* Essai de simplification en retirant des variables explicatives si ça ne détériore pas le modèle

La qualité du modèle final sera évaluée par le pourcentage de pêches où le cran prédit par le modèle est celui qui a été employé sur le terrain. En toute rigueur il aurait été souhaitable de construire le modèle sur une partie des données et de le tester sur une autre partie, mais le nombre des observations étant limité, il aurait été dommage d'en écarter certaines pour élaborer le modèle.

La qualité des modèles intermédiaires sera évaluée sur le [critère d'Akaike (AIC)](https://fr.wikipedia.org/wiki/Crit%C3%A8re_d%27information_d%27Akaike). Plus sa valeur est faible, meilleur est l'ajustement.

### Tests du modèle complet

On commence par construire le modèle complet  (avec les 3 variables explicatives) en essayant plusieurs paramétrages (logistique, probit ...). 

```{r, echo = FALSE, include = FALSE}
mod1 <- MASS::polr(cran ~ prof_moy + conductivite + temperature,
                   method = "logistic",
                   data = data_sel)
summary(mod1, digits = 3)
```


```{r, echo = FALSE, include = FALSE}
mod2 <- update(mod1, method = "probit", Hess = TRUE)
summary(mod2, digits = 3)
```


```{r, echo = FALSE, include = FALSE}
mod3 <- update(mod1, method = "loglog", Hess = TRUE)
summary(mod3, digits = 3)
```



```{r, echo = FALSE, include = FALSE}
mod4 <- update(mod1, method = "cloglog", Hess = TRUE)
summary(mod4, digits = 3)
```

D'après l'AIC on a de meilleurs résultats avec le modèle "cloglog".

Un autre critère de la qualité du modèle est le pourcentage des "crans" qui sont bien prédits.

```{r, echo = FALSE, include = FALSE}
pourcent_bien_classe <- function(table) {
  sum(diag(table)) / sum(table) * 100 %>% round(2)
}
```

Pour ce modèle il est de `r table(predict(mod4, data_sel, type = "class"), data_sel$cran) %>% pourcent_bien_classe() %>% round()`%.

```{r}

```
### Possibilité de le simplifier ?

On procède par étape au moyen de la fonction `stepAIC` du package `MASS`.



```{r, echo = FALSE, include = FALSE}
MASS::stepAIC(mod4)
```

Celle-ci nous indique (non montré ici) que si l'on veut retirer une variable c'est la profondeur moyenne.

On construit donc le modèle : *cran ~ conductivite + temperature*

```{r, echo = FALSE, include = FALSE}
mod5 <- MASS::polr(cran ~ conductivite + temperature,
                   method = "cloglog",
                   data = data_sel)
```

Taux de bien classés : `r table(predict(mod5, data_sel, type = "class"), data_sel$cran) %>% pourcent_bien_classe() %>% round()`%.

$\Rightarrow$ ce modèle est aussi bon que le précédent en prédiction, mais plus simple (seulement deux variables explicatives). On le retirnt donc.

Des essais ont montré que si l'on simplifie encore le modèle (pour ne conserver que la variable explicative `conductivite`), le modèle perd en capacité prédictive. 

La matrice de confusion du modèle retenu est la suivante :

```{r}
predit <- predict(mod5, data_sel, type = "class")
obs <- data_sel$cran
table(obs, predit) %>% 
  as.data.frame.matrix() %>% 
  knitr::kable() %>% 
  kableExtra::add_header_above(c("Cran observé" = 1, "Cran prédit par modèle" = 3),
                               escape = FALSE)
```

Les bonnes prédictions sont sur la diagonale du tableau. Il apparaît que le modèle peine à prédire les crans 2 et 4 qui sont sous-estimés - peut-être faute de données en nombre suffisant.




